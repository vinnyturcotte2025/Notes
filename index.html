<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Notes Pro | Real Implementation</title>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #10b981;
            --dark: #1f2937;
            --light: #f9fafb;
            --gray: #6b7280;
            --danger: #ef4444;
            --warning: #f59e0b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .main-content {
            display: flex;
            min-height: 800px;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: var(--light);
            border-right: 1px solid #e2e8f0;
            padding: 25px;
            display: flex;
            flex-direction: column;
        }

        .sessions-header {
            margin-bottom: 25px;
        }

        .sessions-header h2 {
            color: var(--dark);
            font-size: 1.5rem;
            margin-bottom: 15px;
        }

        #newSessionBtn {
            width: 100%;
            padding: 12px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        #newSessionBtn:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
        }

        .sessions-list {
            flex: 1;
            overflow-y: auto;
        }

        .session-item {
            padding: 15px;
            background: white;
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .session-item:hover {
            border-color: var(--primary);
        }

        .session-item.active {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
        }

        .session-title {
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 5px;
        }

        .session-time {
            font-size: 0.85rem;
            color: var(--gray);
        }

        /* Main Content */
        .content-area {
            flex: 1;
            padding: 30px;
            display: flex;
            flex-direction: column;
        }

        .status-bar {
            background: var(--light);
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--secondary);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-bar.recording .status-indicator {
            background: var(--danger);
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Recording Section */
        .recording-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .waveform-container {
            flex: 1;
            background: #1a1a2e;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            min-height: 200px;
        }

        #waveformCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .recording-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .control-btn {
            padding: 15px 40px;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 200px;
            justify-content: center;
        }

        #recordBtn {
            background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
            color: white;
        }

        #recordBtn:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            transform: translateY(-2px);
        }

        #recordBtn.recording {
            background: linear-gradient(135deg, var(--warning) 0%, #d97706 100%);
            animation: pulse 2s infinite;
        }

        #processBtn {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
        }

        #processBtn:hover:not(:disabled) {
            background: linear-gradient(135deg, var(--primary-dark) 0%, #3730a3 100%);
            transform: translateY(-2px);
        }

        #processBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Transcription Display */
        .transcription-container {
            background: var(--light);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }

        .transcription-container h3 {
            margin-bottom: 15px;
            color: var(--dark);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #transcriptionDisplay {
            font-size: 1.1rem;
            line-height: 1.6;
            color: var(--dark);
            white-space: pre-wrap;
        }

        /* Notes Display */
        .notes-section {
            margin-top: 30px;
        }

        .notes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .notes-header h3 {
            font-size: 1.3rem;
            color: var(--dark);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .notes-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .note-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #e5e7eb;
            transition: all 0.3s;
        }

        .note-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            border-color: var(--primary);
        }

        .note-time {
            font-size: 0.9rem;
            color: var(--gray);
            margin-bottom: 10px;
            background: var(--light);
            padding: 5px 12px;
            border-radius: 15px;
            display: inline-block;
        }

        .note-content {
            color: var(--dark);
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .note-tags {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .tag {
            background: var(--light);
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.85rem;
            color: var(--gray);
        }

        .tag.subject {
            background: rgba(99, 102, 241, 0.1);
            color: var(--primary);
        }

        .tag.task {
            background: rgba(16, 185, 129, 0.1);
            color: var(--secondary);
        }

        /* Export Controls */
        .export-controls {
            margin-top: 30px;
            padding-top: 25px;
            border-top: 2px solid #e5e7eb;
        }

        .export-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .export-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #exportPDF {
            background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
            color: white;
        }

        #exportTXT {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
        }

        #exportJSON {
            background: linear-gradient(135deg, var(--secondary) 0%, #059669 100%);
            color: white;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 400px;
        }

        .modal h2 {
            margin-bottom: 20px;
            color: var(--dark);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--dark);
            font-weight: 600;
        }

        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
        }

        .form-group input:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary);
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }

        .cancel-btn {
            background: var(--light);
            color: var(--dark);
        }

        .confirm-btn {
            background: var(--primary);
            color: white;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
            }
            
            .notes-container {
                grid-template-columns: 1fr;
            }
            
            .control-btn {
                min-width: auto;
                width: 100%;
            }
            
            .recording-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>ðŸŽ¤ Voice Notes Pro</h1>
            <p>Real-time transcription with live waveform & PDF export</p>
        </div>

        <div class="main-content">
            <!-- Sidebar -->
            <aside class="sidebar">
                <div class="sessions-header">
                    <h2>Sessions</h2>
                    <button id="newSessionBtn">
                        <i class="fas fa-plus"></i> New Session
                    </button>
                </div>
                <div class="sessions-list" id="sessionsList">
                    <!-- Sessions will be added here -->
                </div>
            </aside>

            <!-- Main Content -->
            <main class="content-area">
                <!-- Status Bar -->
                <div class="status-bar" id="statusBar">
                    <div class="status-indicator"></div>
                    <span id="statusText">Ready to record</span>
                </div>

                <!-- Recording Section -->
                <section class="recording-section">
                    <!-- Waveform Visualization -->
                    <div class="waveform-container">
                        <canvas id="waveformCanvas"></canvas>
                    </div>

                    <!-- Controls -->
                    <div class="recording-controls">
                        <button class="control-btn" id="recordBtn">
                            <i class="fas fa-microphone"></i> Start Recording
                        </button>
                        <button class="control-btn" id="processBtn" disabled>
                            <i class="fas fa-robot"></i> Process Notes
                        </button>
                    </div>

                    <!-- Live Transcription -->
                    <div class="transcription-container">
                        <h3><i class="fas fa-keyboard"></i> Live Transcription</h3>
                        <div id="transcriptionDisplay">
                            Start speaking to see live transcription here...
                        </div>
                    </div>
                </section>

                <!-- Notes Display -->
                <section class="notes-section">
                    <div class="notes-header">
                        <h3><i class="fas fa-sticky-note"></i> Processed Notes</h3>
                    </div>
                    <div class="notes-container" id="notesContainer">
                        <!-- Notes will be added here -->
                    </div>
                </section>

                <!-- Export Controls -->
                <div class="export-controls">
                    <div class="export-buttons">
                        <button class="export-btn" id="exportPDF">
                            <i class="fas fa-file-pdf"></i> Export PDF
                        </button>
                        <button class="export-btn" id="exportTXT">
                            <i class="fas fa-file-alt"></i> Export TXT
                        </button>
                        <button class="export-btn" id="exportJSON">
                            <i class="fas fa-code"></i> Export JSON
                        </button>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Session Modal -->
    <div class="modal" id="sessionModal">
        <div class="modal-content">
            <h2>New Session</h2>
            <div class="form-group">
                <label for="sessionName">Session Name</label>
                <input type="text" id="sessionName" placeholder="Enter session name">
            </div>
            <div class="form-group">
                <label for="sessionDescription">Description (Optional)</label>
                <textarea id="sessionDescription" rows="3" placeholder="Session description"></textarea>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn cancel-btn" id="cancelBtn">Cancel</button>
                <button class="modal-btn confirm-btn" id="createBtn">Create</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== REAL IMPLEMENTATION ====================
        // This uses actual browser APIs that WORK in modern browsers

        class VoiceNotesApp {
            constructor() {
                // App State
                this.state = {
                    currentSession: null,
                    sessions: JSON.parse(localStorage.getItem('voiceNotesSessions')) || [],
                    isRecording: false,
                    isTranscribing: false,
                    audioContext: null,
                    analyser: null,
                    dataArray: null,
                    mediaRecorder: null,
                    audioChunks: [],
                    recognition: null,
                    transcription: [],
                    notes: [],
                    waveformAnimationId: null,
                    recordingStartTime: null
                };

                // DOM Elements
                this.elements = {
                    sessionsList: document.getElementById('sessionsList'),
                    sessionModal: document.getElementById('sessionModal'),
                    statusBar: document.getElementById('statusBar'),
                    statusText: document.getElementById('statusText'),
                    waveformCanvas: document.getElementById('waveformCanvas'),
                    recordBtn: document.getElementById('recordBtn'),
                    processBtn: document.getElementById('processBtn'),
                    transcriptionDisplay: document.getElementById('transcriptionDisplay'),
                    notesContainer: document.getElementById('notesContainer'),
                    exportPDF: document.getElementById('exportPDF'),
                    exportTXT: document.getElementById('exportTXT'),
                    exportJSON: document.getElementById('exportJSON')
                };

                this.init();
            }

            init() {
                this.setupAudioContext();
                this.setupSpeechRecognition();
                this.renderSessions();
                this.setupEventListeners();
                
                if (this.state.sessions.length === 0) {
                    this.createSession('Sample Session', 'First recording session');
                } else {
                    this.selectSession(0);
                }
            }

            // ==================== AUDIO & WAVEFORM ====================
            
            setupAudioContext() {
                try {
                    this.state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.state.analyser = this.state.audioContext.createAnalyser();
                    this.state.analyser.fftSize = 256;
                    const bufferLength = this.state.analyser.frequencyBinCount;
                    this.state.dataArray = new Uint8Array(bufferLength);
                    
                    this.drawSilentWaveform();
                } catch (error) {
                    console.log('Audio context not available:', error);
                }
            }

            drawWaveform() {
                if (!this.state.analyser || !this.state.dataArray) {
                    this.state.waveformAnimationId = requestAnimationFrame(() => this.drawWaveform());
                    return;
                }

                const canvas = this.elements.waveformCanvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width = canvas.offsetWidth;
                const height = canvas.height = canvas.offsetHeight;

                // Get audio data
                this.state.analyser.getByteTimeDomainData(this.state.dataArray);

                // Clear canvas with gradient background
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(1, '#16213e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);

                // Draw waveform
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#6366f1';
                ctx.beginPath();

                const sliceWidth = width / this.state.dataArray.length;
                let x = 0;

                for (let i = 0; i < this.state.dataArray.length; i++) {
                    const v = this.state.dataArray[i] / 128.0;
                    const y = v * height / 2;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                ctx.lineTo(width, height / 2);
                ctx.stroke();

                // Draw center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();

                this.state.waveformAnimationId = requestAnimationFrame(() => this.drawWaveform());
            }

            drawSilentWaveform() {
                const canvas = this.elements.waveformCanvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width = canvas.offsetWidth;
                const height = canvas.height = canvas.offsetHeight;

                // Clear with gradient background
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(1, '#16213e');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);

                // Draw center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();

                // Draw "Ready to record" text
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.font = '18px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Ready to record', width / 2, height / 2);
            }

            // ==================== SPEECH RECOGNITION ====================

            setupSpeechRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                if (!SpeechRecognition) {
                    console.log('Speech recognition not supported');
                    this.elements.statusText.textContent = 'Speech recognition not available';
                    return;
                }

                this.state.recognition = new SpeechRecognition();
                this.state.recognition.continuous = true;
                this.state.recognition.interimResults = true;
                this.state.recognition.lang = 'en-US';

                this.state.recognition.onstart = () => {
                    this.state.isTranscribing = true;
                    this.elements.statusText.textContent = 'Listening... Speak now';
                };

                this.state.recognition.onresult = (event) => {
                    let finalTranscript = '';
                    let interimTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript + ' ';
                            
                            // Add to transcription with timestamp
                            const timeFromStart = Date.now() - this.state.recordingStartTime;
                            const timestamp = this.formatTime(timeFromStart);
                            
                            this.state.transcription.push({
                                text: transcript,
                                timestamp: timestamp,
                                isFinal: true
                            });
                        } else {
                            interimTranscript += transcript;
                        }
                    }

                    this.updateTranscriptionDisplay(interimTranscript);
                };

                this.state.recognition.onerror = (event) => {
                    console.log('Speech recognition error:', event.error);
                };

                this.state.recognition.onend = () => {
                    this.state.isTranscribing = false;
                    this.elements.statusText.textContent = 'Transcription complete';
                    this.elements.processBtn.disabled = false;
                };
            }

            // ==================== RECORDING ====================

            async startRecording() {
                try {
                    // Get microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        }
                    });

                    // Setup audio processing for waveform
                    if (this.state.audioContext) {
                        const source = this.state.audioContext.createMediaStreamSource(stream);
                        source.connect(this.state.analyser);
                        this.drawWaveform();
                    }

                    // Setup MediaRecorder
                    this.state.mediaRecorder = new MediaRecorder(stream);
                    this.state.audioChunks = [];
                    this.state.transcription = [];
                    this.state.recordingStartTime = Date.now();

                    this.state.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.state.audioChunks.push(event.data);
                        }
                    };

                    this.state.mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(this.state.audioChunks, { type: 'audio/webm' });
                        
                        // Save to current session
                        if (this.state.currentSession !== null) {
                            const reader = new FileReader();
                            reader.readAsDataURL(audioBlob);
                            reader.onloadend = () => {
                                this.state.sessions[this.state.currentSession].audio = reader.result;
                                this.state.sessions[this.state.currentSession].transcription = this.state.transcription;
                                this.saveToLocalStorage();
                            };
                        }

                        // Stop speech recognition
                        if (this.state.recognition && this.state.isTranscribing) {
                            this.state.recognition.stop();
                        }

                        // Stop waveform
                        if (this.state.waveformAnimationId) {
                            cancelAnimationFrame(this.state.waveformAnimationId);
                        }
                        this.drawSilentWaveform();

                        // Update UI
                        this.elements.recordBtn.innerHTML = '<i class="fas fa-microphone"></i> Start Recording';
                        this.elements.recordBtn.classList.remove('recording');
                        this.elements.statusBar.classList.remove('recording');
                    };

                    // Start recording
                    this.state.mediaRecorder.start();
                    this.state.isRecording = true;
                    
                    // Start speech recognition
                    if (this.state.recognition) {
                        this.state.recognition.start();
                    }

                    // Update UI
                    this.elements.recordBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Recording';
                    this.elements.recordBtn.classList.add('recording');
                    this.elements.statusBar.classList.add('recording');
                    this.elements.statusText.textContent = 'Recording...';
                    this.elements.processBtn.disabled = true;

                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    this.elements.statusText.textContent = 'Microphone access denied';
                }
            }

            stopRecording() {
                if (this.state.mediaRecorder && this.state.isRecording) {
                    this.state.mediaRecorder.stop();
                    this.state.isRecording = false;
                    
                    // Stop all audio tracks
                    if (this.state.mediaRecorder.stream) {
                        this.state.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    }
                }
            }

            toggleRecording() {
                if (!this.state.isRecording) {
                    this.startRecording();
                } else {
                    this.stopRecording();
                }
            }

            // ==================== NOTE PROCESSING ====================

            processNotes() {
                if (this.state.transcription.length === 0) {
                    alert('No transcription to process');
                    return;
                }

                this.elements.statusText.textContent = 'Processing notes...';
                
                // Group transcription into notes based on time gaps
                const notes = this.groupTranscriptionIntoNotes(this.state.transcription);
                
                // Analyze each note for tasks and subjects
                const processedNotes = notes.map((note, index) => {
                    const analysis = this.analyzeNote(note.text);
                    return {
                        id: index + 1,
                        time: note.timestamp,
                        content: note.text,
                        task: analysis.task,
                        subject: analysis.subject,
                        tags: analysis.tags
                    };
                });

                this.state.notes = processedNotes;
                this.renderNotes();
                this.elements.statusText.textContent = 'Notes processed successfully';
                
                // Save to session
                if (this.state.currentSession !== null) {
                    this.state.sessions[this.state.currentSession].notes = processedNotes;
                    this.saveToLocalStorage();
                }
            }

            groupTranscriptionIntoNotes(transcription) {
                const notes = [];
                let currentNote = null;
                let lastTimestamp = 0;

                transcription.forEach(item => {
                    if (!item.isFinal) return;
                    
                    const currentTime = this.timeToSeconds(item.timestamp);
                    
                    // If gap is more than 10 seconds or first item, start new note
                    if (!currentNote || (currentTime - lastTimestamp) > 10) {
                        if (currentNote) {
                            notes.push(currentNote);
                        }
                        currentNote = {
                            text: item.text,
                            timestamp: item.timestamp
                        };
                    } else {
                        // Continue current note
                        currentNote.text += ' ' + item.text;
                    }
                    
                    lastTimestamp = currentTime;
                });

                // Add the last note
                if (currentNote) {
                    notes.push(currentNote);
                }

                return notes;
            }

            analyzeNote(text) {
                // Simple keyword analysis (in a real app, this would use NLP)
                const keywords = {
                    tasks: ['need', 'should', 'must', 'will', 'going to', 'plan to', 'create', 'make', 'do', 'fix', 'implement'],
                    subjects: ['project', 'meeting', 'client', 'team', 'code', 'design', 'budget', 'timeline', 'feature']
                };

                const words = text.toLowerCase().split(/\s+/);
                
                // Find tasks
                let task = 'General discussion';
                for (const taskWord of keywords.tasks) {
                    if (text.toLowerCase().includes(taskWord)) {
                        const startIndex = text.toLowerCase().indexOf(taskWord);
                        const taskText = text.substring(startIndex, Math.min(startIndex + 50, text.length));
                        task = taskText.trim();
                        if (task.length > 40) task = task.substring(0, 40) + '...';
                        break;
                    }
                }

                // Find subjects
                let subject = 'General';
                for (const subjectWord of keywords.subjects) {
                    if (text.toLowerCase().includes(subjectWord)) {
                        subject = subjectWord.charAt(0).toUpperCase() + subjectWord.slice(1);
                        break;
                    }
                }

                // Generate tags
                const tags = [];
                if (text.toLowerCase().includes('urgent') || text.toLowerCase().includes('important')) {
                    tags.push('priority');
                }
                if (text.toLowerCase().includes('tomorrow') || text.toLowerCase().includes('today')) {
                    tags.push('time-sensitive');
                }
                tags.push(subject.toLowerCase());

                return { task, subject, tags };
            }

            // ==================== RENDERING ====================

            updateTranscriptionDisplay(interim) {
                let displayText = '';
                
                // Add final transcriptions
                this.state.transcription.forEach(item => {
                    if (item.isFinal) {
                        displayText += `[${item.timestamp}] ${item.text}\n`;
                    }
                });
                
                // Add interim transcription
                if (interim) {
                    displayText += `(Listening...) ${interim}`;
                }
                
                this.elements.transcriptionDisplay.textContent = displayText || 'Start speaking to see live transcription here...';
                
                // Auto-scroll
                this.elements.transcriptionDisplay.scrollTop = this.elements.transcriptionDisplay.scrollHeight;
            }

            renderNotes() {
                const container = this.elements.notesContainer;
                container.innerHTML = '';

                if (this.state.notes.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: var(--gray);">
                            <i class="fas fa-sticky-note" style="font-size: 3rem; margin-bottom: 15px; opacity: 0.5;"></i>
                            <h3>No notes yet</h3>
                            <p>Process your transcription to generate organized notes</p>
                        </div>
                    `;
                    return;
                }

                this.state.notes.forEach(note => {
                    const noteCard = document.createElement('div');
                    noteCard.className = 'note-card';
                    
                    noteCard.innerHTML = `
                        <div class="note-time">${note.time}</div>
                        <div class="note-content">${note.content}</div>
                        <div class="note-tags">
                            <span class="tag subject">${note.subject}</span>
                            <span class="tag task">${note.task}</span>
                            ${note.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                        </div>
                    `;
                    
                    container.appendChild(noteCard);
                });
            }

            renderSessions() {
                const container = this.elements.sessionsList;
                container.innerHTML = '';

                this.state.sessions.forEach((session, index) => {
                    const sessionItem = document.createElement('div');
                    sessionItem.className = 'session-item';
                    if (this.state.currentSession === index) {
                        sessionItem.classList.add('active');
                    }
                    
                    const date = new Date(session.created || Date.now());
                    const formattedDate = date.toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    
                    sessionItem.innerHTML = `
                        <div class="session-title">${session.name}</div>
                        <div class="session-time">${formattedDate}</div>
                        <div style="font-size: 0.85rem; color: var(--gray); margin-top: 5px;">
                            ${session.notes ? session.notes.length : 0} notes
                        </div>
                    `;
                    
                    sessionItem.addEventListener('click', () => this.selectSession(index));
                    container.appendChild(sessionItem);
                });
            }

            // ==================== SESSION MANAGEMENT ====================

            createSession(name, description) {
                const newSession = {
                    id: Date.now(),
                    name: name || 'New Session',
                    description: description || '',
                    created: new Date().toISOString(),
                    audio: null,
                    transcription: [],
                    notes: []
                };
                
                this.state.sessions.push(newSession);
                this.saveToLocalStorage();
                this.renderSessions();
                this.selectSession(this.state.sessions.length - 1);
            }

            selectSession(index) {
                this.state.currentSession = index;
                this.renderSessions();
                
                const session = this.state.sessions[index];
                this.state.transcription = session.transcription || [];
                this.state.notes = session.notes || [];
                
                // Update UI
                this.updateTranscriptionDisplay('');
                this.renderNotes();
                this.elements.processBtn.disabled = this.state.transcription.length === 0;
                
                // Update status
                this.elements.statusText.textContent = `Loaded: ${session.name}`;
                setTimeout(() => {
                    this.elements.statusText.textContent = 'Ready to record';
                }, 2000);
            }

            // ==================== EXPORT FUNCTIONS ====================

            exportPDF() {
                if (this.state.notes.length === 0) {
                    alert('No notes to export');
                    return;
                }

                const session = this.state.sessions[this.state.currentSession];
                
                // Create PDF using jsPDF (if available) or simple text download
                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();
                    
                    // Add title
                    doc.setFontSize(20);
                    doc.text(`Voice Notes: ${session.name}`, 20, 20);
                    
                    doc.setFontSize(12);
                    doc.text(`Date: ${new Date(session.created).toLocaleDateString()}`, 20, 30);
                    
                    if (session.description) {
                        doc.text(`Description: ${session.description}`, 20, 36);
                    }
                    
                    // Add notes
                    let y = 50;
                    doc.setFontSize(14);
                    doc.text('Notes:', 20, y);
                    y += 10;
                    
                    doc.setFontSize(11);
                    this.state.notes.forEach((note, index) => {
                        if (y > 270) {
                            doc.addPage();
                            y = 20;
                        }
                        
                        doc.text(`[${note.time}] ${note.subject}`, 20, y);
                        y += 7;
                        doc.text(`Task: ${note.task}`, 25, y);
                        y += 7;
                        
                        // Split content into lines
                        const lines = doc.splitTextToSize(note.content, 170);
                        lines.forEach(line => {
                            doc.text(line, 25, y);
                            y += 7;
                        });
                        
                        y += 5;
                    });
                    
                    // Save PDF
                    doc.save(`voice-notes-${session.name.toLowerCase().replace(/\s+/g, '-')}.pdf`);
                    
                } catch (error) {
                    console.log('jsPDF not available, using text export');
                    this.exportTXT();
                }
            }

            exportTXT() {
                if (this.state.notes.length === 0) {
                    alert('No notes to export');
                    return;
                }

                const session = this.state.sessions[this.state.currentSession];
                let content = `VOICE NOTES EXPORT\n`;
                content += `==================\n\n`;
                content += `Session: ${session.name}\n`;
                content += `Date: ${new Date(session.created).toLocaleDateString()}\n`;
                if (session.description) content += `Description: ${session.description}\n`;
                content += `\n`.repeat(2);
                content += `NOTES\n`;
                content += `=====\n\n`;
                
                this.state.notes.forEach((note, index) => {
                    content += `Note ${index + 1} [${note.time}]\n`;
                    content += `Subject: ${note.subject}\n`;
                    content += `Task: ${note.task}\n`;
                    content += `Content: ${note.content}\n`;
                    content += `Tags: ${note.tags.join(', ')}\n`;
                    content += `\n`.repeat(2);
                });
                
                this.downloadFile(content, 'text/plain', `${session.name.toLowerCase().replace(/\s+/g, '-')}.txt`);
            }

            exportJSON() {
                const session = this.state.sessions[this.state.currentSession];
                const exportData = {
                    session: session.name,
                    date: session.created,
                    description: session.description,
                    notes: this.state.notes,
                    transcription: this.state.transcription
                };
                
                const content = JSON.stringify(exportData, null, 2);
                this.downloadFile(content, 'application/json', `${session.name.toLowerCase().replace(/\s+/g, '-')}.json`);
            }

            downloadFile(content, mimeType, filename) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // ==================== UTILITIES ====================

            formatTime(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            timeToSeconds(timeStr) {
                const [minutes, seconds] = timeStr.split(':').map(Number);
                return minutes * 60 + seconds;
            }

            saveToLocalStorage() {
                localStorage.setItem('voiceNotesSessions', JSON.stringify(this.state.sessions));
            }

            // ==================== EVENT HANDLERS ====================

            setupEventListeners() {
                // Recording controls
                this.elements.recordBtn.addEventListener('click', () => this.toggleRecording());
                this.elements.processBtn.addEventListener('click', () => this.processNotes());
                
                // Export buttons
                this.elements.exportPDF.addEventListener('click', () => this.exportPDF());
                this.elements.exportTXT.addEventListener('click', () => this.exportTXT());
                this.elements.exportJSON.addEventListener('click', () => this.exportJSON());
                
                // Session modal
                document.getElementById('newSessionBtn').addEventListener('click', () => {
                    document.getElementById('sessionName').value = '';
                    document.getElementById('sessionDescription').value = '';
                    this.elements.sessionModal.style.display = 'flex';
                });
                
                document.getElementById('cancelBtn').addEventListener('click', () => {
                    this.elements.sessionModal.style.display = 'none';
                });
                
                document.getElementById('createBtn').addEventListener('click', () => {
                    const name = document.getElementById('sessionName').value.trim();
                    const description = document.getElementById('sessionDescription').value.trim();
                    
                    if (!name) {
                        alert('Please enter a session name');
                        return;
                    }
                    
                    this.createSession(name, description);
                    this.elements.sessionModal.style.display = 'none';
                });
                
                // Close modal on outside click
                window.addEventListener('click', (e) => {
                    if (e.target === this.elements.sessionModal) {
                        this.elements.sessionModal.style.display = 'none';
                    }
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === ' ') {
                        e.preventDefault();
                        this.toggleRecording();
                    }
                    if (e.key === 'Escape' && this.state.isRecording) {
                        this.stopRecording();
                    }
                });
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    if (!this.state.isRecording) {
                        this.drawSilentWaveform();
                    }
                });
            }
        }

        // Initialize app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new VoiceNotesApp();
        });

        // Add Font Awesome dynamically
        const faLink = document.createElement('link');
        faLink.rel = 'stylesheet';
        faLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css';
        document.head.appendChild(faLink);
    </script>
</body>
</html>
