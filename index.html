<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clean Voice Notes | Transcript & Structure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .app-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        /* Main Content */
        .main-content {
            display: flex;
            min-height: 800px;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: #f8fafc;
            border-right: 1px solid #e2e8f0;
            padding: 25px;
            display: flex;
            flex-direction: column;
        }

        .sidebar-header {
            margin-bottom: 25px;
        }

        .sidebar-header h2 {
            color: #1e293b;
            font-size: 1.5rem;
            margin-bottom: 15px;
        }

        #newNoteBtn {
            width: 100%;
            padding: 12px;
            background: #4f46e5;
            color: white;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        #newNoteBtn:hover {
            background: #4338ca;
            transform: translateY(-2px);
        }

        .notes-list {
            flex: 1;
            overflow-y: auto;
        }

        .note-item {
            padding: 15px;
            background: white;
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.3s;
        }

        .note-item:hover {
            border-color: #4f46e5;
        }

        .note-item.active {
            border-color: #4f46e5;
            background: rgba(79, 70, 229, 0.05);
        }

        .note-title {
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 5px;
        }

        .note-time {
            font-size: 0.85rem;
            color: #64748b;
        }

        /* Main Area */
        .main-area {
            flex: 1;
            padding: 30px;
            display: flex;
            flex-direction: column;
        }

        /* Status Bar */
        .status-bar {
            background: #f1f5f9;
            padding: 15px 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 600;
            color: #475569;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #10b981;
        }

        .status-bar.recording .status-indicator {
            background: #ef4444;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Recording Controls */
        .recording-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 25px;
        }

        .control-btn {
            padding: 15px 40px;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
            min-width: 200px;
            justify-content: center;
        }

        #recordBtn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        #recordBtn:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            transform: translateY(-2px);
        }

        #recordBtn.recording {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }

        #clearBtn {
            background: #f1f5f9;
            color: #475569;
            border: 2px solid #e2e8f0;
        }

        #clearBtn:hover {
            background: #e2e8f0;
        }

        /* Waveform Container */
        .waveform-container {
            flex: 1;
            background: #0f172a;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            margin-bottom: 25px;
            min-height: 200px;
        }

        #waveformCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .waveform-label {
            position: absolute;
            bottom: 15px;
            left: 0;
            right: 0;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }

        /* Transcription Area */
        .transcription-container {
            background: #f8fafc;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            max-height: 300px;
            overflow-y: auto;
        }

        .transcription-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .transcription-header h3 {
            color: #1e293b;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #transcriptionDisplay {
            font-size: 1.1rem;
            line-height: 1.6;
            color: #1e293b;
            white-space: pre-wrap;
        }

        /* Notes Display */
        .notes-display {
            background: white;
            border-radius: 15px;
            padding: 25px;
            border: 2px solid #e2e8f0;
        }

        .notes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .notes-header h3 {
            color: #1e293b;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .notes-content {
            max-height: 400px;
            overflow-y: auto;
        }

        .formatted-note {
            background: #f8fafc;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            border-left: 4px solid #4f46e5;
        }

        .note-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e2e8f0;
        }

        .note-time-badge {
            background: #4f46e5;
            color: white;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .note-text {
            color: #1e293b;
            line-height: 1.6;
            font-size: 1rem;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #64748b;
        }

        .empty-state .icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* Export Controls */
        .export-controls {
            margin-top: 25px;
            padding-top: 25px;
            border-top: 2px solid #e2e8f0;
        }

        .export-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .export-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #exportTXT {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
        }

        #exportTXT:hover {
            background: linear-gradient(135deg, #4338ca 0%, #6d28d9 100%);
        }

        #exportJSON {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        #exportJSON:hover {
            background: linear-gradient(135deg, #0da271 0%, #047857 100%);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 400px;
        }

        .modal h2 {
            margin-bottom: 20px;
            color: #1e293b;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #475569;
            font-weight: 600;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
        }

        .form-group input:focus {
            outline: none;
            border-color: #4f46e5;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
        }

        .cancel-btn {
            background: #f1f5f9;
            color: #475569;
        }

        .save-btn {
            background: #4f46e5;
            color: white;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
            }
            
            .control-btn {
                min-width: auto;
                width: 100%;
            }
            
            .recording-controls {
                flex-direction: column;
            }
            
            .export-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>üó£Ô∏è Clean Voice Notes</h1>
            <p>Real-time transcription with structured notes - No AI, just clean text</p>
        </div>

        <div class="main-content">
            <!-- Sidebar -->
            <aside class="sidebar">
                <div class="sidebar-header">
                    <h2>üìù Notes</h2>
                    <button id="newNoteBtn">
                        <i class="fas fa-plus"></i> New Note
                    </button>
                </div>
                <div class="notes-list" id="notesList">
                    <!-- Notes will be added here -->
                </div>
            </aside>

            <!-- Main Area -->
            <main class="main-area">
                <!-- Status Bar -->
                <div class="status-bar" id="statusBar">
                    <div class="status-indicator"></div>
                    <span id="statusText">Ready to record</span>
                </div>

                <!-- Recording Controls -->
                <div class="recording-controls">
                    <button class="control-btn" id="recordBtn">
                        <i class="fas fa-microphone"></i> Start Recording
                    </button>
                    <button class="control-btn" id="clearBtn">
                        <i class="fas fa-eraser"></i> Clear
                    </button>
                </div>

                <!-- Waveform Visualization -->
                <div class="waveform-container">
                    <canvas id="waveformCanvas"></canvas>
                    <div class="waveform-label">Live Audio Waveform</div>
                </div>

                <!-- Live Transcription -->
                <div class="transcription-container">
                    <div class="transcription-header">
                        <h3><i class="fas fa-keyboard"></i> Live Transcription</h3>
                    </div>
                    <div id="transcriptionDisplay">
                        Click "Start Recording" and speak to begin transcription...
                    </div>
                </div>

                <!-- Structured Notes Display -->
                <div class="notes-display">
                    <div class="notes-header">
                        <h3><i class="fas fa-sticky-note"></i> Structured Notes</h3>
                    </div>
                    <div class="notes-content" id="notesContent">
                        <div class="empty-state">
                            <div class="icon">üìù</div>
                            <h3>No structured notes yet</h3>
                            <p>Your formatted notes will appear here</p>
                        </div>
                    </div>
                </div>

                <!-- Export Controls -->
                <div class="export-controls">
                    <div class="export-buttons">
                        <button class="export-btn" id="exportTXT">
                            <i class="fas fa-file-alt"></i> Export as Text
                        </button>
                        <button class="export-btn" id="exportJSON">
                            <i class="fas fa-code"></i> Export as JSON
                        </button>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Note Modal -->
    <div class="modal" id="noteModal">
        <div class="modal-content">
            <h2>Save Note</h2>
            <div class="form-group">
                <label for="noteTitle">Note Title</label>
                <input type="text" id="noteTitle" placeholder="Enter note title">
            </div>
            <div class="modal-buttons">
                <button class="modal-btn cancel-btn" id="cancelBtn">Cancel</button>
                <button class="modal-btn save-btn" id="saveBtn">Save</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== REAL IMPLEMENTATION ====================
        // Working speech recognition with real waveform visualization

        class VoiceNotesApp {
            constructor() {
                this.state = {
                    currentNote: null,
                    notes: JSON.parse(localStorage.getItem('cleanVoiceNotes')) || [],
                    isRecording: false,
                    isTranscribing: false,
                    audioContext: null,
                    analyser: null,
                    mediaStream: null,
                    mediaRecorder: null,
                    audioChunks: [],
                    recognition: null,
                    transcription: [],
                    recordingStartTime: null,
                    waveformAnimationId: null,
                    dataArray: null
                };

                // DOM Elements
                this.elements = {
                    notesList: document.getElementById('notesList'),
                    noteModal: document.getElementById('noteModal'),
                    statusBar: document.getElementById('statusBar'),
                    statusText: document.getElementById('statusText'),
                    waveformCanvas: document.getElementById('waveformCanvas'),
                    recordBtn: document.getElementById('recordBtn'),
                    clearBtn: document.getElementById('clearBtn'),
                    transcriptionDisplay: document.getElementById('transcriptionDisplay'),
                    notesContent: document.getElementById('notesContent'),
                    exportTXT: document.getElementById('exportTXT'),
                    exportJSON: document.getElementById('exportJSON'),
                    noteTitle: document.getElementById('noteTitle')
                };

                this.init();
            }

            init() {
                this.setupAudioContext();
                this.setupSpeechRecognition();
                this.renderNotesList();
                this.setupEventListeners();
                
                if (this.state.notes.length === 0) {
                    this.createNote('First Note');
                } else {
                    this.selectNote(0);
                }

                // Initialize waveform
                this.drawEmptyWaveform();
            }

            // ==================== AUDIO & WAVEFORM ====================

            setupAudioContext() {
                try {
                    this.state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.state.analyser = this.state.audioContext.createAnalyser();
                    this.state.analyser.fftSize = 2048; // More data for better waveform
                    const bufferLength = this.state.analyser.frequencyBinCount;
                    this.state.dataArray = new Uint8Array(bufferLength);
                } catch (error) {
                    console.log('Audio context initialization:', error);
                }
            }

            drawEmptyWaveform() {
                const canvas = this.elements.waveformCanvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width = canvas.offsetWidth;
                const height = canvas.height = canvas.offsetHeight;

                // Clear with dark background
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, width, height);

                // Draw grid
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;

                // Vertical lines
                for (let i = 1; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo((width / 4) * i, 0);
                    ctx.lineTo((width / 4) * i, height);
                    ctx.stroke();
                }

                // Horizontal lines
                for (let i = 1; i < 4; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, (height / 4) * i);
                    ctx.lineTo(width, (height / 4) * i);
                    ctx.stroke();
                }

                // Draw center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();

                // Draw "Ready" text
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Ready to Record', width / 2, height / 2);
            }

            drawWaveform() {
                if (!this.state.analyser || !this.state.dataArray) {
                    this.state.waveformAnimationId = requestAnimationFrame(() => this.drawWaveform());
                    return;
                }

                const canvas = this.elements.waveformCanvas;
                const ctx = canvas.getContext('2d');
                const width = canvas.width = canvas.offsetWidth;
                const height = canvas.height = canvas.offsetHeight;

                // Get audio data
                this.state.analyser.getByteTimeDomainData(this.state.dataArray);

                // Clear canvas
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, width, height);

                // Draw waveform
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#4f46e5';
                ctx.beginPath();

                const sliceWidth = width / this.state.dataArray.length;
                let x = 0;

                for (let i = 0; i < this.state.dataArray.length; i++) {
                    // Normalize data to -1 to 1
                    const v = this.state.dataArray[i] / 128.0;
                    const y = (v * height) / 2;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                ctx.stroke();

                // Draw center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();

                this.state.waveformAnimationId = requestAnimationFrame(() => this.drawWaveform());
            }

            // ==================== SPEECH RECOGNITION ====================

            setupSpeechRecognition() {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                
                if (!SpeechRecognition) {
                    console.log('Speech recognition not available');
                    this.elements.statusText.textContent = 'Speech recognition not supported in this browser';
                    this.elements.recordBtn.disabled = true;
                    return;
                }

                this.state.recognition = new SpeechRecognition();
                this.state.recognition.continuous = true;
                this.state.recognition.interimResults = true;
                this.state.recognition.lang = 'en-US';
                this.state.recognition.maxAlternatives = 1;

                this.state.recognition.onstart = () => {
                    this.state.isTranscribing = true;
                    this.elements.statusText.textContent = 'Listening... Speak now';
                };

                this.state.recognition.onresult = (event) => {
                    let finalTranscript = '';
                    let interimTranscript = '';

                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                            
                            // Add to transcription with timestamp
                            const timeFromStart = Date.now() - this.state.recordingStartTime;
                            const timestamp = this.formatTime(timeFromStart);
                            
                            this.state.transcription.push({
                                text: transcript.trim(),
                                timestamp: timestamp,
                                isFinal: true
                            });
                        } else {
                            interimTranscript = transcript;
                        }
                    }

                    this.updateTranscriptionDisplay(interimTranscript);
                };

                this.state.recognition.onerror = (event) => {
                    console.log('Speech recognition error:', event.error);
                    if (event.error === 'no-speech') {
                        this.elements.statusText.textContent = 'No speech detected';
                    }
                };

                this.state.recognition.onend = () => {
                    this.state.isTranscribing = false;
                    if (!this.state.isRecording) {
                        this.elements.statusText.textContent = 'Transcription complete';
                        this.structureNotes();
                    }
                };
            }

            // ==================== RECORDING ====================

            async startRecording() {
                try {
                    // Reset transcription
                    this.state.transcription = [];
                    this.state.recordingStartTime = Date.now();
                    this.updateTranscriptionDisplay('');

                    // Get microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        }
                    });

                    this.state.mediaStream = stream;
                    this.state.audioChunks = [];

                    // Setup audio processing for waveform
                    if (this.state.audioContext) {
                        const source = this.state.audioContext.createMediaStreamSource(stream);
                        source.connect(this.state.analyser);
                        this.drawWaveform();
                    }

                    // Setup MediaRecorder
                    this.state.mediaRecorder = new MediaRecorder(stream);

                    this.state.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.state.audioChunks.push(event.data);
                        }
                    };

                    this.state.mediaRecorder.onstop = () => {
                        const audioBlob = new Blob(this.state.audioChunks, { type: 'audio/webm' });
                        
                        // Save to current note
                        if (this.state.currentNote !== null) {
                            const reader = new FileReader();
                            reader.readAsDataURL(audioBlob);
                            reader.onloadend = () => {
                                this.state.notes[this.state.currentNote].audio = reader.result;
                                this.state.notes[this.state.currentNote].transcription = this.state.transcription;
                                this.saveToLocalStorage();
                            };
                        }

                        // Stop waveform
                        if (this.state.waveformAnimationId) {
                            cancelAnimationFrame(this.state.waveformAnimationId);
                        }
                        this.drawEmptyWaveform();

                        // Update UI
                        this.elements.recordBtn.innerHTML = '<i class="fas fa-microphone"></i> Start Recording';
                        this.elements.recordBtn.classList.remove('recording');
                        this.elements.statusBar.classList.remove('recording');
                    };

                    // Start recording
                    this.state.mediaRecorder.start(1000); // Collect data every second
                    this.state.isRecording = true;
                    
                    // Start speech recognition
                    if (this.state.recognition) {
                        this.state.recognition.start();
                    }

                    // Update UI
                    this.elements.recordBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Recording';
                    this.elements.recordBtn.classList.add('recording');
                    this.elements.statusBar.classList.add('recording');
                    this.elements.statusText.textContent = 'Recording...';
                    this.elements.clearBtn.disabled = true;

                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    this.elements.statusText.textContent = 'Microphone access denied';
                }
            }

            stopRecording() {
                if (this.state.mediaRecorder && this.state.isRecording) {
                    this.state.mediaRecorder.stop();
                    this.state.isRecording = false;
                    
                    // Stop speech recognition
                    if (this.state.recognition && this.state.isTranscribing) {
                        this.state.recognition.stop();
                    }
                    
                    // Stop audio tracks
                    if (this.state.mediaStream) {
                        this.state.mediaStream.getTracks().forEach(track => track.stop());
                    }
                    
                    this.elements.clearBtn.disabled = false;
                }
            }

            clearTranscription() {
                this.state.transcription = [];
                this.updateTranscriptionDisplay('Click "Start Recording" and speak to begin transcription...');
                this.clearStructuredNotes();
                this.elements.statusText.textContent = 'Cleared';
                setTimeout(() => {
                    this.elements.statusText.textContent = 'Ready to record';
                }, 1000);
            }

            // ==================== NOTE STRUCTURING ====================

            structureNotes() {
                if (this.state.transcription.length === 0) return;

                // Group transcription into logical paragraphs
                const paragraphs = this.groupIntoParagraphs(this.state.transcription);
                
                // Format each paragraph
                const formattedNotes = paragraphs.map(paragraph => {
                    return {
                        timestamp: paragraph.timestamp,
                        text: this.cleanText(paragraph.text),
                        duration: paragraph.duration
                    };
                });

                // Display structured notes
                this.displayStructuredNotes(formattedNotes);

                // Save to current note
                if (this.state.currentNote !== null) {
                    this.state.notes[this.state.currentNote].structuredNotes = formattedNotes;
                    this.saveToLocalStorage();
                }
            }

            groupIntoParagraphs(transcription) {
                const paragraphs = [];
                let currentParagraph = null;
                let lastTime = 0;

                transcription.forEach(item => {
                    if (!item.isFinal) return;

                    const currentTime = this.timeToSeconds(item.timestamp);
                    
                    // If gap > 5 seconds or first item, start new paragraph
                    if (!currentParagraph || (currentTime - lastTime) > 5) {
                        if (currentParagraph) {
                            paragraphs.push(currentParagraph);
                        }
                        currentParagraph = {
                            text: item.text,
                            timestamp: item.timestamp,
                            startTime: currentTime
                        };
                    } else {
                        // Continue current paragraph
                        currentParagraph.text += ' ' + item.text;
                    }
                    
                    lastTime = currentTime;
                });

                // Add the last paragraph
                if (currentParagraph) {
                    const endTime = lastTime;
                    currentParagraph.duration = endTime - currentParagraph.startTime;
                    paragraphs.push(currentParagraph);
                }

                return paragraphs;
            }

            cleanText(text) {
                // Basic text cleaning
                return text
                    .replace(/\s+/g, ' ') // Remove extra spaces
                    .replace(/\s([.,!?])/g, '$1') // Fix spacing before punctuation
                    .replace(/^./, str => str.toUpperCase()) // Capitalize first letter
                    .trim();
            }

            // ==================== DISPLAY FUNCTIONS ====================

            updateTranscriptionDisplay(interim) {
                let displayText = '';
                
                // Add all final transcriptions
                this.state.transcription.forEach(item => {
                    if (item.isFinal) {
                        displayText += `[${item.timestamp}] ${item.text}\n`;
                    }
                });
                
                // Add interim transcription if available
                if (interim && interim.trim()) {
                    displayText += `...${interim}`;
                }
                
                this.elements.transcriptionDisplay.textContent = displayText || 'Click "Start Recording" and speak to begin transcription...';
                
                // Auto-scroll to bottom
                this.elements.transcriptionDisplay.scrollTop = this.elements.transcriptionDisplay.scrollHeight;
            }

            displayStructuredNotes(notes) {
                const container = this.elements.notesContent;
                
                if (notes.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="icon">üìù</div>
                            <h3>No structured notes yet</h3>
                            <p>Your formatted notes will appear here</p>
                        </div>
                    `;
                    return;
                }

                let html = '';
                notes.forEach((note, index) => {
                    html += `
                        <div class="formatted-note">
                            <div class="note-meta">
                                <span class="note-time-badge">${note.timestamp}</span>
                                <span style="color: #64748b; font-size: 0.9rem;">
                                    ${note.duration ? `Duration: ${note.duration}s` : ''}
                                </span>
                            </div>
                            <div class="note-text">
                                ${note.text}
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = html;
            }

            clearStructuredNotes() {
                this.elements.notesContent.innerHTML = `
                    <div class="empty-state">
                        <div class="icon">üìù</div>
                        <h3>No structured notes yet</h3>
                        <p>Your formatted notes will appear here</p>
                    </div>
                `;
            }

            renderNotesList() {
                const container = this.elements.notesList;
                container.innerHTML = '';

                this.state.notes.forEach((note, index) => {
                    const noteItem = document.createElement('div');
                    noteItem.className = 'note-item';
                    if (this.state.currentNote === index) {
                        noteItem.classList.add('active');
                    }
                    
                    const date = new Date(note.created || Date.now());
                    const formattedDate = date.toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric'
                    });
                    
                    noteItem.innerHTML = `
                        <div class="note-title">${note.title}</div>
                        <div class="note-time">${formattedDate}</div>
                        <div style="font-size: 0.85rem; color: #64748b; margin-top: 5px;">
                            ${note.transcription ? note.transcription.length : 0} segments
                        </div>
                    `;
                    
                    noteItem.addEventListener('click', () => this.selectNote(index));
                    container.appendChild(noteItem);
                });
            }

            // ==================== NOTE MANAGEMENT ====================

            createNote(title) {
                const newNote = {
                    id: Date.now(),
                    title: title || 'New Note',
                    created: new Date().toISOString(),
                    audio: null,
                    transcription: [],
                    structuredNotes: []
                };
                
                this.state.notes.push(newNote);
                this.saveToLocalStorage();
                this.renderNotesList();
                this.selectNote(this.state.notes.length - 1);
            }

            selectNote(index) {
                this.state.currentNote = index;
                this.renderNotesList();
                
                const note = this.state.notes[index];
                this.state.transcription = note.transcription || [];
                
                // Update displays
                this.updateTranscriptionDisplay('');
                if (note.structuredNotes && note.structuredNotes.length > 0) {
                    this.displayStructuredNotes(note.structuredNotes);
                } else {
                    this.clearStructuredNotes();
                }
                
                // Update status
                this.elements.statusText.textContent = `Loaded: ${note.title}`;
                setTimeout(() => {
                    this.elements.statusText.textContent = 'Ready to record';
                }, 1500);
            }

            // ==================== EXPORT FUNCTIONS ====================

            exportAsText() {
                const note = this.state.notes[this.state.currentNote];
                if (!note || (!note.transcription.length && !note.structuredNotes.length)) {
                    alert('No notes to export');
                    return;
                }

                let content = `=== ${note.title} ===\n`;
                content += `Created: ${new Date(note.created).toLocaleString()}\n\n`;
                
                if (note.structuredNotes && note.structuredNotes.length > 0) {
                    content += 'STRUCTURED NOTES:\n';
                    content += '=================\n\n';
                    note.structuredNotes.forEach((item, index) => {
                        content += `[${item.timestamp}] ${item.text}\n\n`;
                    });
                } else if (note.transcription.length > 0) {
                    content += 'TRANSCRIPTION:\n';
                    content += '==============\n\n';
                    note.transcription.forEach(item => {
                        if (item.isFinal) {
                            content += `[${item.timestamp}] ${item.text}\n`;
                        }
                    });
                }

                this.downloadFile(content, 'text/plain', `${note.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.txt`);
            }

            exportAsJSON() {
                const note = this.state.notes[this.state.currentNote];
                const exportData = {
                    note: {
                        title: note.title,
                        created: note.created,
                        transcription: note.transcription,
                        structuredNotes: note.structuredNotes || []
                    }
                };
                
                const content = JSON.stringify(exportData, null, 2);
                this.downloadFile(content, 'application/json', `${note.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.json`);
            }

            downloadFile(content, mimeType, filename) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // ==================== UTILITIES ====================

            formatTime(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }

            timeToSeconds(timeStr) {
                const [minutes, seconds] = timeStr.split(':').map(Number);
                return minutes * 60 + seconds;
            }

            saveToLocalStorage() {
                localStorage.setItem('cleanVoiceNotes', JSON.stringify(this.state.notes));
            }

            // ==================== EVENT HANDLERS ====================

            setupEventListeners() {
                // Recording controls
                this.elements.recordBtn.addEventListener('click', () => {
                    if (!this.state.isRecording) {
                        this.startRecording();
                    } else {
                        this.stopRecording();
                    }
                });

                this.elements.clearBtn.addEventListener('click', () => this.clearTranscription());
                
                // Export buttons
                this.elements.exportTXT.addEventListener('click', () => this.exportAsText());
                this.elements.exportJSON.addEventListener('click', () => this.exportAsJSON());
                
                // Note creation
                document.getElementById('newNoteBtn').addEventListener('click', () => {
                    this.elements.noteTitle.value = '';
                    this.elements.noteModal.style.display = 'flex';
                });
                
                document.getElementById('cancelBtn').addEventListener('click', () => {
                    this.elements.noteModal.style.display = 'none';
                });
                
                document.getElementById('saveBtn').addEventListener('click', () => {
                    const title = this.elements.noteTitle.value.trim();
                    if (!title) {
                        alert('Please enter a note title');
                        return;
                    }
                    
                    this.createNote(title);
                    this.elements.noteModal.style.display = 'none';
                });
                
                // Close modal on outside click
                window.addEventListener('click', (e) => {
                    if (e.target === this.elements.noteModal) {
                        this.elements.noteModal.style.display = 'none';
                    }
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === ' ') {
                        e.preventDefault();
                        if (!this.state.isRecording) {
                            this.startRecording();
                        } else {
                            this.stopRecording();
                        }
                    }
                    if (e.key === 'Escape' && this.state.isRecording) {
                        this.stopRecording();
                    }
                });
                
                // Handle window resize
                window.addEventListener('resize', () => {
                    if (!this.state.isRecording) {
                        this.drawEmptyWaveform();
                    }
                });
            }
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', () => {
            new VoiceNotesApp();
        });

        // Add Font Awesome
        const faScript = document.createElement('script');
        faScript.src = 'https://kit.fontawesome.com/a076d05399.js';
        faScript.crossOrigin = 'anonymous';
        document.head.appendChild(faScript);
    </script>
</body>
</html>
